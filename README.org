* Aprenda Haskell Rápido e Difícil :TOC_3_gh:
  - [[#exploda-sua-cabeça-com-haskell][Exploda sua cabeça com Haskell]]
- [[#introdução][Introdução]]
  - [[#instalação][Instalação]]
  - [[#não-tenha-medo][Não tenha medo]]
  - [[#haskell-muito-básico][Haskell muito básico]]
    - [[#um-exemplo-usando-tipos][Um exemplo usando Tipos]]
- [[#haskell-básico][Haskell básico]]
  - [[#notações][Notações]]
  - [[#notações-para-funções-uteis][Notações para funções uteis]]
- [[#nível-de-dificuldade---hard][Nível de dificuldade - HARD]]
  - [[#estilo-funcional][Estilo funcional]]
  - [[#funções-de-ordem-elevadas][Funções de ordem elevadas]]
  - [[#tipos][Tipos]]
    - [[#inferência-de-tipos][Inferência de tipos]]
    - [[#construção-de-tipos][Construção de tipos]]
    - [[#tipos-recursivos][Tipos recursivos]]
    - [[#estruturas-infinitas][Estruturas infinitas]]
- [[#nível-de-dificuldade---hell][Nível de dificuldade - HELL]]
  - [[#lidando-com-io][Lidando com IO]]
  - [[#explicando-truques-com-io][Explicando truques com IO]]
  - [[#monads][Monads]]
  - [[#a-lista-monad][A lista monad]]
- [[#anexo][Anexo]]
  - [[#mais-sobre-arvore-infinita][Mais sobre Arvore Infinita]]

** Exploda sua cabeça com Haskell

[[file:images/_20210725_102116screenshot.png]]

Um tutorial pequeno e denso para aprender Haskell.

Eu realmente acredito que todos os desenvolvedores deveriam aprender Haskell. Eu
não acho que todo mundo precisa ser super Haskell ninjas, mas que pelo menos
pudessem descobrir o que o Haskell tem para oferecer.

Aprender Haskell abre sua mente.

As linguagens de programação mais utilizadas compartilham as mesmas fundações:

- variáveis
- _loops_
- ponteiros
- estruturas de dados, objetos e classes

Haskell é bem diferente. A linguagem usa vários conceitos que eu nunca tinha
ouvido falar antes. Muitos desses conceitos vão ajudar você a se tornar um
programador melhor.

Mas aprender Haskell pode ser bem difícil. Foi assim pra mim. Nesse artigo eu
tento passar o que faltou pra mim enquanto eu aprendia Haskell.

Esse artigo vai ser difícil de ser seguido. Isso é proposital. Não há atalhos
para aprender Haskell. É difícil e desafiador, mas eu acredito que isso é uma
coisa boa.

O método convencional para aprender Haskell se resume em ler dois livros.
Primeiro, "[[http://learnyouahaskell.com/][Learn You a Haskell]]" e depois "[[http://book.realworldhaskell.org][Real World Haskell]]". Eu acredito que
essa é a melhor forma de fato, mas para aprender do que se trata Haskell de
verdade, você precisa ler esses livros nos detalhes.

Em contrapartida, esse artigo é uma visão geral bem resumida e densa de todas os
aspectos gerais de Haskell. Eu também adicionei algumas informações que eu não
tinha quando eu aprendi Haskell.

O artigo contém 5 partes:

1. Introdução: breve exemplo para mostrar que Haskell pode ser amigável
2. Haskell básico: sintaxe e algumas noções essenciais
3. Nível de dificuldade - *HARD*:
   a. Estilo funcional: um exemplo progressivo do estilo imperativo para o funcional
   b. Tipos: tipos e exemplo de uma arvore binaria
   c. Sequencias infinitas: manipular uma arvore binaria infinita
4. Nível de dificuldade - *HELL*
   a. Lidando com IO: um pequeno exemplo
   b. Explicando truques envolvendo IO: os detalhes escondidos para entender IO
   c. _Monads_: generalizações incríveis
5. Anexo
   a. Mais sobre arvores infinitas: uma discussão mais orientada usando matemática


* Introdução
** Instalação

[[file:images/_20210725_105352screenshot.png]]

Existem diferentes formas para instalar o Haskell, eu recomendo utilizar o
[[https://docs.haskellstack.org/en/stable/README/][stack]]. As outras formas de instalar Haskell vão depender bastante do seu
sistema, você pode aprender mais sobre isso visitando [[https://www.haskell.org][haskell.org]] ou
[[https://www.fpcomplete.com/haskell/][haskell-lang.org]].

Ferramentas:
- =ghc=: Compilador similar ao gcc para =C=
- =ghci=: Haskell Interativo (REPL)
- =runhaskell=: Execute um programa sem compilar ele. Bastante conveniente, mas
  é bem mais lento do que executar o programa compilado.

#+begin_quote
Nota{Wand}: Caso você use o Emacs, recomendo o [[https://github.com/hlissner/doom-emacs][Doom]] emacs e basta habilitar
  a camada de Haskell +lsp.
#+end_quote


** Não tenha medo

[[file:images/_20210725_105402screenshot.png]]

Muitos livros e artigos sobre Haskell iniciam com alguma formula esotérica
(quicksort, Fibonacci, etc). Eu vou pelo extremo oposto. De inicio não vou te
mostrar nenhum super poder do Haskell. Eu vou iniciar com as similaridades entre
Haskell e outras linguagens de programação. Vamos começar com o obrigatório
"Hello World".

#+begin_src haskell
main = putStrLn "Hello World!"
#+end_src

Para rodar, você precisa salvar esse código em um arquivo =hello.hs= e:

#+begin_src shell
~ runhaskell ./hello.hs
Hello World!
#+end_src

ou se você estiver usando =stack=, primeiro rode =stack setup= e depois:

#+begin_src shell
~ stack runhaskell ./hello.hs
Hello World!
#+end_src

-------

Agora vamos criar um programa perguntando pelo seu nome e respondendo "Hello"
usando o nome que você forneceu:

#+begin_src haskell
main = do
  print "What is your name?"
  name <- getLine
  print ("Hello " ++ name ++ "!")
#+end_src

Vamos comparar como esse programa seria implementado em algumas linguagens
imperativas:

#+begin_src python
# Python

print "What is your name?"
name = raw_input()
print "Hello %s!" % name
#+end_src

#+begin_src ruby
# Ruby

puts "What is your name?"
name = gets.chomp
puts "Hello #{name}!"
#+end_src

#+begin_src c
// In C

#include <stdio.h>
int main (int argc, char **argv) {
    char name[666]; // <- An Evil Number!
    // What if my name is more than 665 character long?
    printf("What is your name?\n");
    scanf("%s", name);
    printf("Hello %s!\n", name);
    return 0;
}
#+end_src

A estrutura é a mesma, mas existem algumas diferenças de sintaxe. A principal
parte desse tutorial vai ser dedicada a explicar o por quê.

Em Haskell existe a função =main= e todos os objetos tem um =tipo=. O tipo da
função =main= é =IO()=. Isso significa que =main= vai causar algum efeito
colateral.

Lembre-se que Haskell pode se parecer bastante com linguagens de programação
mais comuns.

** Haskell muito básico

[[file:images/_20210725_105419screenshot.png]]

Antes de continuar, você precisa ser avisado sobre algumas propriedades
essenciais do Haskell.


*Funcional*

Haskell é uma linguagem funcional. Se você vem tem experiência com linguagens
imperativas, você vai precisar aprender um monte de coisas novas. Felizmente,
muitos desses novos conceitos vão te ajudar a programar até nas linguagens
imperativas.


*Tipagem Estática Inteligente*

No lugar de te atrapalhar como no caso de =C=, =C++=, ou =Java=, o sistema de
tipos do Haskell tenta o máximo possível te ajudar.


*Pureza*

Geralmente suas funções não vão modificar nada fora seu ambiente de execução.
Isso significa que essas funções não podem modificar valores de variáveis, não
podem pegar valores de entrada de usuários, não podem escrever na sua tela, não
podem lançar misseis. Por outro lado, paralelismo vai ser bem fácil de alcançar.
Haskell deixa muito claro onde os *efeitos* podem ocorrer e onde o seu código é
puro. Dessa forma, vai ser bem mais fácil de racionalizar sobre o seu programa e
a maioria dos bugs vai ser prevenido nas partes puras do seu programa.

Além disso, funções puras seguem uma lei fundamental em Haskell:

#+begin_quote
Aplicar uma função com os mesmos parâmetros vai sempre retornar o mesmo resultado
#+end_quote


*Laziness*

*Laziness* (preguiça) ser o comportamento padrão é bastante incomum em
linguagens de programação. Por padrão, Haskell só vai calcular algo quando for
necessário. Por consequência disso, Haskell também prove uma forma elegante de
manipular estruturas infinitas, por exemplo.

Um ultimo aviso sobre como você deveria ler um código Haskell. Para mim, a
leitura é como se fosse um artigo cientifico. Algumas partes são claras, mas
quando você encontra uma formula, só foque e leia mais devagar. Além disso,
enquanto aprende Haskell, realmente não importa se você não entendeu os detalhes
da sintaxe. Por exemplo, caso encontre um =>>==, =<$>=, =<-= ou qualquer outro
simbolo esquisito, só ignore eles e continue seguindo o fluxo de execução do
código

*** COMMENT Declaração de Funções

Você pode estar acostumado a declarar funções dessa forma:

In C:
#+begin_src c
int f(int x, int y) {
    return x*x + y*y;
}
#+end_src

In JavaScript:
#+begin_src javascript
function f(x,y) {
    return x*x + y*y;
}
#+end_src

In Python:
#+begin_src python
def f(x,y):
    return x*x + y*y
#+end_src

In Ruby:
#+begin_src ruby
def f(x,y)
  x*x + y*y
end
#+end_src

In Scheme:
#+begin_src scheme
(define (f x y)
  (+ (* x x) (* y y)))
#+end_src

Finalmente, em Haskell:
#+begin_src haskell
f x y = x**x + y*y
#+end_src

Bem limpo. Sem parenteses, sem =def=.

Não se esqueça que Haskell usa muito funções e tipos, dessa forma é bem simples
definir esses elementos. A sintaxe foi particularmente escolhida para esses
objetos.


*** Um exemplo usando Tipos

Embora não seja obrigatório, a informação sobre o tipo para as funções é
geralmente feita explicitamente. Não é obrigatório porque o compilador é esperto
o suficiente para descobrir esses tipos para você. Porém, é uma boa ideia
declarar os tipos explicitamente porque indica qual era a sua intenção quando
escreveu o programa e melhora o entendimento de quem for ler o código.

Vamos experimentar um pouco. A declaração de um tipo se faz usando =::=

#+begin_src haskell
f :: Int -> Int -> Int
f x y = x*x + y*y

main = print (f 2 3)
#+end_src

#+begin_src shell
~ runhaskell arquivo_com_codigo_acima_salvo.lhs
13
#+end_src


--------

Agora tente:

#+begin_src haskell
f :: Int -> Int -> Int
f x y = x*x + y*y

main = print (f 2.3 4.2)
#+end_src

Você deve receber esse erro:

#+begin_src shell
arquivo_com_codigo_acima_salvo.lhs:6:23:
    No instance for (Fractional Int)
      arising from the literal `4.2'
    Possible fix: add an instance declaration for (Fractional Int)
    In the second argument of `f', namely `4.2'
    In the first argument of `print', namely `(f 2.3 4.2)'
    In the expression: print (f 2.3 4.2)
#+end_src

O problema: =4.2= não é um =Int=.

--------

A solução: não declare o tipo para a função =f= por enquanto e deixe o Haskell
inferir o tipo mais genérico que ele conseguir para nós:

#+begin_src haskell
f x y = x*x + y*y

main = print (f 2.3 4.2)
#+end_src

Funcionou! Felizmente, não precisamos declarar uma nova função para cada tipo de
dado diferente que queremos suportar. Por exemplo, em =C= você teria que
declarar uma função que aceita =Int=, uma para =float=, uma para =long=, uma
para =double=, etc.

Mas quais tipos devemos declarar? Para descobrir o tipo que o Haskell encontrou
para nós, vamos utilizar o =ghci= (REPL):

#+begin_src shell
% ghci
GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude> let f x y = x*x + y*y
Prelude> :type f
f :: Num a => a -> a -> a
#+end_src

Uhm? Que tipo é esse?

#+begin_src haskell
Num a => a -> a -> a
#+end_src

Primeiro, vamos focar na parte da direita =a -> a -> a=. Para entender isso,
vamos analisar esses exemplos:

| Tipo           | Significado                                                            |
|----------------+------------------------------------------------------------------------|
| =Int=          | o tipo =Int=                                                           |
| =Int -> Int=   | uma função tipada que mapeia de =Int= para =Int=                       |
| =Float -> Int= | uma função tipada que mapeia de =Float= para =Int=                     |
| =a -> Int=     | uma função tipada que mapeia qualquer tipo para =Int=                  |
| =a -> a=       | uma função tipada que mapeia qualquer tipo =a= para o mesmo tipo =a=   |
| =a -> a -> a=  | uma função tipada de dois argumentos de tipo =a= para o mesmo tipo =a= |

No tipo =a -> a -> a=, a letra =a= é uma =variável de tipo=. Isso significa que
=f= é uma função com dois argumentos e ambos os argumentos e o resultado tem o
mesmo tipo. A variável de tipo =a= pode assumir vários valores de tipos
diferentes, por exemplo, =Int=, =Integer=, =Float=, etc.

Ou seja, no lugar de ter tipos forçados como em =C= e precisar declarar funções
para =Int=, =long=, =float=, =double=, etc, nós declaramos apenas uma função
similar ao que acontece em linguagens dinamicamente tipadas.

Esse comportamento é chamado de polimorfismo paramétrico.

Geralmente =a= pode ser qualquer tipo, por exemplo uma =String= ou um =Int=, mas
também pode ser tipos mais complexos como =Trees= ou outras funções.

Mas nesse caso não vamos esquecer que o nosso tipo está prefixado com =Num a
=>=. =Num= é uma *classe de tipos*, uma classe de tipos pode ser entendida como
um conjunto de tipos. =Num= contem tipos que se comportam como números mais
precisamente, =Num= é o conjunto de tipos que implementam as funções =(+)= e
=(*)=.

Classes de tipos são recursos da linguagem muito poderosos. Nós podemos fazer
coisas bem poderosas com isso, mais sobre isso depois.

Finalmente, =Num a => a -> a -> a= significa:

Seja =a= um tipo que pertence ao conjunto de tipos =Num=. Essa é uma função do
tipo =a= para =a -> a=.

Sim, esquisito. De fato, em Haskell nenhuma função tem dois argumentos na
realidade. Todas as funções tem apenas um argumento, mas podemos notar que
receber dois argumentos é equivalente a receber apenas um e retornar uma função
que recebe o segundo.

Mais precisamento =f 3 4= é equivalente a =(f 3) 4=. Note que =f 3= é a função:

#+begin_src haskell
f :: Num a => a -> a -> a
g :: Num a => a -> a
g = f 3

g y <=> 3*3 + y*y
#+end_src

Podemos usar uma outra notação para funções. A notação lambda permite criar
funções sem definir um nome para elas, ou seja, criamos funções anonimas. Assim,
podiamos ter escrito:

#+begin_src haskell
g = \y -> 3*3 + y*y
#+end_src

O =\= é usado porque se parece com =λ= em ASCII.

Se você não está acostumado com programação funcional o seu cérebro deve estar
começando a esquentar. Agora é hora de criar uma aplicação de verdade.

-------

Mas antes disso, nós deveriamos verificar que o sistema de tipos do Haskell está
funcionando como o esperado:

#+begin_src haskell
f :: Num a => a -> a -> a
f x y = x*x + y*y

main = print (f 3 2.4)
#+end_src

Funciona porque =3= é uma representação válida para ambos números Fracionados
como =Float= quanto para =Integer=.

--------

Se forçarmos a nossa função para funcionar com tipos de dados diferentes, ela
vai falhar:

#+begin_src haskell
f :: Num a => a -> a -> a
f x y = x*x + y*y

x :: Int
x = 3

y :: Float
y = 2.4

-- não funciona porque o tipo de x é diferente do tipo de y
main = print (f x y)
#+end_src

O compilador reclama! *Os dois parâmetros precisam ter o mesmo tipo!*

Se você acredita que isso é uma má ideia e que o compilador deveria fazer a
transformação de um tipo para o outro para você, aconselho você a assistir esse
ótimo (e engraçado) video: [[https://www.destroyallsoftware.com/talks/wat][WAT]]


* Haskell básico

[[file:images/_20210725_134647screenshot.png]]

Eu sugiro que você faça uma breve leitura dessa parte. Pense nisso como uma
referencia. Haskell tem um monte de funcionalidades e por isso tem um monte de
informação faltando nesse trecho.

Aconselho a voltar nessa parte caso a notação comece a parecer esquisita.

Eu vou usar o symbolo =⇔= para indicar que duas expressões são equivalentes.
Isso é uma notação aleatória que estou inventando, não existe no Haskell. Da
mesma forma, vou utilizar o =⇒= para indicar o valor de retorno de uma
expressão.

** Notações

*Aritmética*
#+begin_src haskell
3 + 2 * 6 / 3 ⇔ ((2*6)/3)
#+end_src

*Lógica*
#+begin_src haskell
True || False ⇒ True
True && False ⇒ False
True == False ⇒ False
True =/ False ⇒ True (/=) é o operador de "diferente"
#+end_src

*Exponenciação*
#+begin_src haskell
x^n  para qualquer n `integral` (ou seja, Int ou Integer)
x**y para qualquer y que seja um número (Float, Double, etc)
#+end_src

=Integer= não tem limite exceto pela capacidade do seu computador:

#+begin_src haskell
4^103
102844034832575377634685573909834406561420991602098741459288064
#+end_src

Yeah! E também tem suporte para números racionais! Mas, para usar essa
funcionalidade você precisa importar o modulo =Data.Ratio=:

#+begin_src shell
$ ghci
....
Prelude> :m Data.Ratio
Data.Ratio> (11 % 15) * (5 % 3)
11 % 9
#+end_src

*Listas*
#+begin_src haskell
[]                     ⇔ lista vazia
[1,2,3]                ⇔ lista de Integral
["foo","bar","baz"]    ⇔ lista de String
1:[2,3]                ⇔ [1,2,3], (:) prepend um elemento
1:2:[]                 ⇔ [1,2]
[1,2] ++ [3,4]         ⇔ [1,2,3,4]  (++) concatenação
[1,2,3] ++ ["foo"]     ⇔ ERROR String diferente de Integral
[1..4]                 ⇔ [1,2,3,4]
[1,3..10]              ⇔ [1,3,5,7,9]
[2,3,5,7,11,..100]     ⇔ ERROR! O compilador não é tão esperto assim!
[10,9..1]              ⇔ [10,9,8,7,6,5,4,3,2,1]
#+end_src

*Strings*
Em Haskell as Strings são listas de =Char=
#+begin_src haskell
'a':: Char
"a" :: [Char]
"" ⇔ []
"ab" ⇔ ['a', 'b'] ⇔ 'a':"b" ⇔ 'a':['b'] ⇔ 'a':'b':[]
"abc" ⇔ "ab"++"c"
#+end_src

#+begin_quote
Alerta: Em códigos reais você não deveria usar lista de =Char= para representar
texto. Você deve utilizar o modulo =Data.Text=. Caso queira representar uma
=stream= de ASCII char, você pode usar =Data.ByteString=.
#+end_quote

*Tuplas*
O tipo tupla é =(a,b)=. Elementos em uma tupla podem ter tipos diferentes.
#+begin_src haskell
-- All these tuples are valid
(2, "foo")
(3, 'a', [2,3])
((2,"a"), "c", 3)

fst (x,y) ⇒ x
snd (x,y) ⇒ y

fst (x,y,z) ⇒ ERROR fst :: (a,b) -> a
snd (x,y,z) ⇒ ERROR snd :: (a,b) -> b
#+end_src


*Parenteses*

Para remover parenteses você pode fazer uso de duas funções: =($)= e =(.)=

#+begin_src haskell
-- By default
f g h x ⇔ (((f g) h) x)

-- the $ replace parenthesis from the $
-- to the end of the expression
f g $ h x     ⇔  f g (h x)   ⇔ (f g) (h x)
f $ g h x     ⇔  f (g h x)   ⇔ f ((g h) x)
f $ g $ h x   ⇔  f (g (h x)) ⇔ f ((g h) x)

-- (.) the composition function
(f . g) x      ⇔  f (g x)
(f . g . h) x  ⇔  f (g (h x))
#+end_src


** Notações para funções uteis

Um lembrete:

#+begin_src haskell
x :: Int             ⇔  x é do tipo Int
x :: a               ⇔  x pode ser de qualquer tipo
x :: Num a => a      ⇔  x pode ser qualquer tipo tanto que pertença a classe de tipos Num

f :: a -> b          ⇔ f é uma função que mapeia de a para b
f :: a -> b -> c     ⇔ f é uma função que mapeia de a para (b->c)
f :: (a -> b) -> c   ⇔ f é uma função que mapeia de (a->b) para c

#+end_src

Lembre-se que definir o tipo de uma função antes de declará-la não é
obrigatório. O Haskell infere os tipos mais gerais para você, mas é considerado
uma boa prática para fazer de qualquer forma.

*Notação infixa*

#+begin_src haskell
square :: Num a => a -> a
square x = x ^ 2
#+end_src

Note que =^= usa a notação infixa. Para cada operador infixo existe um associado
na notação prefixa, basta que você adicione o operador dentro de parenteses.

#+begin_src haskell
square' x = (^) x 2
square '' x = (^2) x

#+end_src

Podemos remover =x= no lado esquerdo e direito da equação acima! Isso é chamado
=η-redução=.

#+begin_src haskell
square''' = (^2)
#+end_src

*Testes*

Uma implementação da função =absoluta=.

#+begin_src haskell
absolute :: (Ord a, Num a) => a -> a
absolute x = if x >= 0 then x else -x
#+end_src

Note que =if .. then .. else= em Haskell é bem parecido com o operador ternário
=¤?¤:¤=. Você não pode esquecer de informar o =else=.

Outra versão equivalente:
#+begin_src haskell
absolute'x
  | x >= 0 = x
  | otherwise = -x
#+end_src

#+begin_quote
Alerta sobre notação: Indentação é *importante* em Haskell. Assim como em
Python, má indentação pode quebrar seu código!
#+end_quote


* Nível de dificuldade - HARD

A parte difícil pode começar agora.

** Estilo funcional

[[file:images/_20210725_195209screenshot.png]]

Nessa seção, eu vou dar um pequeno exemplo do poder impressionante de
refatoração de código que o Haskell provê. Nós vamos selecionar um problema e
resolvê-lo utilizando um estilo imperativo convencional, depois eu vou evoluir o
código até chegarmos na versão funcional.

A versão final vai ser ao mesmo tempo mais elegante e mais fácil de se adaptar.

Vamos resolver o seguinte problema:

#+begin_quote
Dada uma lista de inteiros, retorne a soma dos números pares dessa lista.
Exemplo: =[1,2,3,4,5] ⇒ 2 + 4 ⇒ 6
#+end_quote


Para demonstrar as diferenças entre os estilos imperativo e funcional, eu vou
iniciar com uma implementação imperativa em JavaScript:

#+begin_src javascript
function evenSum(list) {
    var result = 0;
    for (var i=0; list.length; i++) {
        if (list[i] % 2 == 0) {
            result += list[i];
        }
    }
    return result;
}
#+end_src

Em Haskell, por outro lado, nós não temos variáveis ou um =for loop=. Uma
solução para alcançar o mesmo resultado sem utilizar =loops= é através da
recursão.

#+begin_quote
Observação: Recursão é geralmente entendida como algo *lento* em linguagens
imperativas, porém geralmente isso não é verdade em linguagens functionais. A
maioria das vezes o Haskell vai tratar a recursão de funções de forma eficiente.
#+end_quote

Aqui temos uma versão em C utilizando funções recursivas. Note que para
simplificar, eu assumi que a lista de inteiros vai acabar quando encontrar o
primeiro valor 0 dentro da lista.

#+begin_src c
int evenSum(int *list) {
    return accumSum(0, list);
}

int accumSum(int n, int *list) {
    int x;
    int *xs;
    if (*list == 0) { // se a lista está vazia
        return n;
    } else {
        x = list[0];
        xs = list + 1;
        if (0 == (x%2)) { // se x é par
            return accumSum(n+x, xs);
        } else {
            return accumSum(n, xs);
        }
    }
}
#+end_src


Mantenha esse código na cabeça. Nós vamos traduzi-lo para Haskell. Primeiro,
entretanto, eu preciso introduzir três funcões simples mas muito uteis que nós
vamos usar:

#+begin_src haskell
even :: Integral a => a -> Bool
head :: [a] -> a
tail :: [a] -> [a]
#+end_src

=even= verifica se um número é par.
#+begin_src haskell
even :: Integral a => a -> Bool
even 3 ⇒ False
even 2 ⇒ True
#+end_src

=head= retorna o primeiro elemento de uma lista.
#+begin_src haskell
head :: [a] -> a
head [1,2,3] ⇒ 1
head [] ⇒ ERROR
#+end_src

=tail= retorna todos os elementos da lista, exceto o primeiro.
#+begin_src haskell
tail :: [a] -> [a]
tail [1,2,3]  ⇒ [2,3]
tail [3]      ⇒ []
tail []       ⇒ ERROR
#+end_src

Note que para qualquer lista não vazia, =l ⇔ (head l):(tail l)=

-------

A primeira solução para o problema proposto em Haskell. A função =evenSum=
retorna a soma de todos os números pares em uma lista:

#+begin_src haskell
-- Version 1
evenSum :: [Integer] -> Integer

evenSum l = accumSum 0 l
accumSum n l = if l == []
               then n
               else let x = head l
                        xs = tail l
                    in if even x
                          then accumSum (n+x) xs
                       else accumSum n xs
#+end_src

Para testar a função você pode utilizar o =ghci=:

#+begin_src shell
% ghci
GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude> :load 11_Functions.lhs
[1 of 1] Compiling Main             ( 11_Functions.lhs, interpreted )
Ok, modules loaded: Main.
,*Main> evenSum [1..5]
6
#+end_src

Segue o exemplo do fluxo de execução da chamada em Haskell:
#+begin_src shell
,*Main> evenSum [1..5]
accumSum 0 [1,2,3,4,5]
1 is odd
accumSum 0 [2,3,4,5]
2 is even
accumSum (0+2) [3,4,5]
3 is odd
accumSum (0+2) [4,5]
2 is even
accumSum (0+2+4) [5]
5 is odd
accumSum (0+2+4) []
l == []
0+2+4
0+6
6
#+end_src

Mesmo vindo de uma experiência com linguagens imperativas tudo deve parecer
tranquilo. De fato, muitas coisas podem ser melhoradas nessa primeira
implementação. Primeiro, podemos generalizar os tipos.

#+begin_src haskell
evenSum :: Integral a => [a] -> a
#+end_src


-------

Depois, nós podemos utilizar a função =where= ou =let= e assim a função
=accumSum= não precisa poluir o nosso modulo.

#+begin_src haskell
-- Versao 2
evenSum :: Integral a => [a] -> a
evenSum l = accumSum 0 l
  where accumSum n l =
          if l == []
          then n
          else let x = head l
                   xs = tail l
                   in if even x
                      then accumSum (n+x) xs
                      else accumSum n xs
#+end_src

Depois, nós podemos utilizar =pattern matching=.

#+begin_src haskell
-- Versao 3
evenSum l = accumSum 0 l
  where
    accumSum n [] = n
    accumSum n (x:xs) =
      if even x
      then accumSum (n+x) xs
      else accumSum n xs
#+end_src

O que é =pattern matching=? Nós estamos usando *valores* no lugar dos nomes dos
parâmetros para fazer escolha do =branch= de execução.

No lugar de falar: =foo l = if l == [] then <x> else <y>=, você pode
simplesmente dizer:

#+begin_src haskell
foo [] = <x>
foo l = <y>
#+end_src

Mas =pattern matching= pode ir muito além, pois também é possível inspecionar a
estrutura interna dos dados. Podemos substituir:

#+begin_src haskell
foo l = let x = head l
            xs = tail l
            in if even x
               then foo (n+x) xs
               else foo n xs
#+end_src

por

#+begin_src haskell
foo (x:xs) = if even x
             then foo (n+x) xs
             else foo n xs
#+end_src

Essa é uma funcionalidade muito útil porque deixa o nosso código mais enxuto e
fácil de ler.

------

Em Haskell você pode simplificar a definição de uma função através da técnica de
=η-redução=. Por exemplo, no lugar de escrever:

#+begin_src haskell
f x = (alguma expressao) x
#+end_src

Você pode simplesmente escrever
#+begin_src haskell
f = alguma expressao
#+end_src

Usando esse método, nós podemos remover o =l= da implementação 3.
#+begin_src haskell
-- versao 4
evenSum :: Integral a => [a] -> a
evenSum = accumSum 0
  where
    accumSum n [] = n
    accumSum n (x:xs) =
      if even x
      then accumSum (n+x) xs
      else accumSum n xs
#+end_src

** Funções de ordem elevadas

[[file:images/_20210725_195232screenshot.png]]

Para fazer as coisas ainda melhores, nós devemos utilizar funções de ordens
elevadas. O que são esses monstros? Funções de ordem elevadas são funções que
recebem outras funções como parâmetros.

Alguns exemplos:
#+begin_src haskell
filter :: (a -> Bool) -> [a] -> [a]
map :: (a -> b) -> [a] -> [b]
foldl :: (a -> b -> a) -> a -> [b] -> a
#+end_src


Vamos prosseguir em passos pequenos.

#+begin_src haskell
-- versao 5
evenSum l = mysum 0 (filter even l)
  where
    mysum n [] = n
    mysum n (x:xs) = mysum (n+x) xs
#+end_src

sendo que
#+begin_src haskell
filter even [1..10] ⇔ [2,4,6,8,10]
#+end_src

A função =filter= recebe uma função do tipo =(a -> Bool)= e uma lista do tipo
=[a]= e retorna uma lista contendo somente elementos em que a função informada
retornou =true=.

Nosso próximo passo é utilizar uma outra técnica para realizar a mesma coisa que
o =loop=. Nós vamos utilizar a função =foldl= para acumular os valores enquanto
atravessamos a lista. A função =foldl= captura esse padrão geral de código:

#+begin_src haskell
myfunc list = foo initialValue list
foo accumulated [] = accumulated
foo tmpValue (x:xs) = foo (var tmpValue x) xs

#+end_src

Que pode ser simplesmente substituido por:
#+begin_src haskell
myfunc list = foldl bar initialValue list
#+end_src

Se você quer realmente saber como a mágica acontece, essa é a definição de
=foldl=:

#+begin_src haskell
foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

foldl f z [x1,...xn] ⇔ f (... (f (f z x1) x2) ...) xn
#+end_src

Mas como Haskell é preguiçoso, ele não calcula =(f z x)= imediatamente e
simplesmente carrega o valor para a stack. Esse é o motivo que geralmente usa-se
o *foldl'* no lugar do =foldl=; *foldl'* é a versão =strict= do =foldl=. Se você
não entende o que é preguiçoso e =strict=, não se preocupe, siga o código como
se =foldl= e *foldl'* fossem identicos.

Agora, a nossa nova versão de =evenSum= se torna:

#+begin_src haskell
-- Versao 6
-- foldl' não é accessível por padrão
-- nós precisamos importar do modulo Data.List

import Data.List
evenSum l = foldl' mysum 0 (filter even l)
  where mysum acc value = acc + value
#+end_src

Nós podemos simplificar essa Implementação utilizando a notação lambda. Dessa
forma, não precisamos criar um nome temporário =mysum=

#+begin_src haskell
-- versao 7
-- geralmente é considerado uma boa prática
-- em importar somente as funções necessárias de um módulo
import Data.List (foldl')
evenSum l = foldl' (\x y -> x + y) 0 (filter even l)
#+end_src

Logo notamos que:
#+begin_src haskell
(\x y -> x+y) ⇔ (+)
#+end_src

Finalmente temos nossa versão final:
#+begin_src haskell
-- versao 8
import Data.List (foldl')
evenSum :: Integral a => [a] -> a
evenSum l = foldl' (+) 0 (filter even l)
#+end_src

=foldl'= não é uma função fácil de entender. Se você não está acostumado com
ela, você deveria estudá-la um pouco. Para ajudar o entendimento do que está
acontecendo dentro da função, segue um passo a passo do fluxo de execução:

#+begin_src haskell
  evenSum [1,2,3,4]
⇒ foldl' (+) 0 (filter even [1,2,3,4])
⇒ foldl' (+) 0 [2,4]
⇒ foldl' (+) (0+2) [4]
⇒ foldl' (+) 2 [4]
⇒ foldl' (+) (2+4) []
⇒ foldl' (+) 6 []
⇒ 6
#+end_src

Uma outra função de ordem elevado é a =(.)=. A função =(.)= corresponde a
composição matemática.

#+begin_src haskell
(f . g . h) x ⇔ f (g (h x))
#+end_src

Nós podemos utilizar a composição para reduzir a nossa função =evenSum=

#+begin_src haskell
-- versao 9
import Data.List (foldl')
evenSum :: Integral a => [a] -> a
evenSum = (foldl' (+) 0) . (filter even)
#+end_src

Além disso, nós podemos até renomear cada uma das partes para tornar ainda mais
claro:

#+begin_src haskell
-- versao 10
import Data.List (foldl')
sum' :: (Num a) => [a] -> a
sum' = foldl'(+) 0
evenSum :: Integral a => [a] -> a
evenSum = sum'. (filter even)
#+end_src

Agora é hora de discutir a direção que nosso código tomou enquanto introduziamos
mais idiomas funcionais. O que ganhamos ao introduzir funções de ordens
elevadas?

A principio você pode pensar que a principal diferença é o quão enxuto o código
está, mas de fato, tem muito mais a ver com uma forma de pensar melhor. Suponha
que queremos modificar nossa função para, por exemplo, calcular a soma de todos
os pares ao quadrado de uma lista qualquer:

#+begin_src shell
[1,2,3,4] -> [1,4,9,16] -> [4, 16] -> 2
#+end_src

Atualizando a versão 10 é extremamente fácil:

#+begin_src haskell
squareEvenSum = sum' . (filter even) . (map (^2))
squareEvenSum' = evenSum . (map (^2))
#+end_src

Nós só tivemos que adicionar uma "função de transformação" adicional.

A função =map= apenas aplica uma função em todos os elementos de uma lista.

Nós não tivemos que modificar nada *dentro* da definição da função original, ou
seja, esse comportamento faz com que nosso código seja mais modular. Mas além
disso, você pode pensar de forma mais matemática sobre suas funções. Você pode
tratar essa nova função como se fosse uma função builtin, ou seja, você pode
utilizá-la junto com map, fold, filter, etc.

Modificar a versão 1 para o novo requisito é deixado como exercício para o
leitor ☺.

Se você acha que chegamos no final da *generalização*, então você está muito
errado! Por exemplo, existe uma forma de utilizar essa função não apenas em
listas mas em qualquer estrutura de dados de tipo recursivo. Se você quer saber
como, eu sugiro a leitura desse artigo bem divertido: [[http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf][Functional Programming
with Bananas, Lenses, Envelopes and Barbed Wire by Meijer, Fokkinga and Paterson]].

Esse exemplo deveria ter te mostrado o quão interessante programação puramente
funcional pode ser, porém infelizmente, usar programação puramente funcional não
é aconselhável para todos os casos de uso. Ou pelo menos nenhuma linguagem que
atenda esse requisito foi encontrada ainda.

Um dos super poderes do Haskell é a habilidade de criar DSLs (Domain Specific
Language) sendo bem fácil de trocar o paradigma de programação. De fato, Haskell
é também muito bom caso você queira programar no estilo imperativo.

Entender isso foi realmente muito difícil para mim enquanto aprendia sobre
Haskell. Muito esforço tende ser colocado para explicar a superioridade da
abordagem funcional e depois quando você começa usar o estilo imperativo no
Haskell pode ser um pouco difícil entender quando e como usar isso.

Mas antes de falar sobre esse outro super-poder do Haskell, nós devemos falar
sobre outro aspecto essencial do Haskell: Tipos.

** Tipos

[[file:images/_20210725_195248screenshot.png]]

#+begin_quote
tl;dr:
- =type Name = AnotherType= é somente um alias e o compilador não ve nenhuma diferença entre os dois
- =data Name = NameConstructor AnotherType= são tipos diferentes para o compilador
- =data= pode construir estruturas que podem ser recursivas
- =deriving= é mágico e cria funções para você
#+end_quote

Em Haskell, tipos são fortes e estáticos.

Por que isso é importante? Isso vai te ajudar *muito* a evitar erros. Em
Haskell, a maioria dos defeitos são pegos durante a fase de compilação do
programa e o principal responsável são as inferências de tipo feitas pelo
compilador.

Inferência de tipo torna fácil detectar onde você usou o parâmetro errado no
lugar errado, por exemplo.

*** Inferência de tipos

Tipagem estática é geralmente essencial para execuções rápidas, mas a maioria
das linguagens tipadas são ruins em generalizar conceitos. Uma das maiores
vantagens do Haskell é ser capaz de *inferir tipos*

Segue um simples exemplo, a função =square= em Haskell:

#+begin_src haskell
square x = x * x
#+end_src

Essa função pode aceitar qualquer tipo númerico. Você pode passar um =Int=,
=Integer=, =Float=, =Fractional=, ou até mesmo o tipo =Complex=.

#+begin_src shell
% ghci
GHCi, version 7.0.4:
...
Prelude> let square x = x*x
Prelude> square 2
4
Prelude> square 2.1
4.41
Prelude> -- load the Data.Complex module
Prelude> :m Data.Complex
Prelude Data.Complex> square (2 :+ 1)
3.0 :+ 4.0
#+end_src

=x :+ y= é a notação do número complexo (x + iy).

Agora compare com a quantidade de código necessário para fazer a mesma coisa em
=C=.

#+begin_src c
int     int_square(int x) { return x*x; }

float   float_square(float x) {return x*x; }

complex complex_square (complex z) {
    complex tmp;
    tmp.real = z.real * z.real - z.img * z.img;
    tmp.img = 2 * z.img * z.real;
}

complex x,y;
y = complex_square(x);
#+end_src

Para cada tipo, você precisa definir uma nova função. A único truque para fazer
isso de uma maneira mais concisa em C é utilizar meta-programação, por exemplo,
utilizando pré-processadores.

Em C++ existe uma forma melhor, usando C++ templates:

#+begin_src c++
#include <iostream>
#include <complex>
using namespace std;

template<typename T>
T square(T x)
{
    return x*x;
}

int main() {
    // int
    int sqr_of_five = square(5);
    cout << sqr_of_five << endl;
    // double
    cout << (double)square(5.3) << endl;
    // complex
    cout << square( complex<double>(5,3) )
         << endl;
    return 0;
}
#+end_src

A funcionalidade do C++ comparado com o C é bem melhor, porém para funções mais
complexas a sintaxe pode ser bem complicada de seguir: veja esse [[https://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/][artigo]] por
exemplo. Em C++ você precisa declarar que uma função pode aceitar diferentes
tipos, em Haskell acontece ao contrário: a função vai ser tão geral quanto
possível por padrão.

A inferência de tipos em Haskell nos provê a sensação de liberdade que
linguagens dinamicamente tipadas tem, mas diferente de linguagens dinamicamente
tipadas, a maioria dos erros são pegos antes do programa chegar em tempo de
execução.

Geralmente em Haskell:

#+begin_quote
Se compila, certamente faz o que você queria.
#+end_quote

------

*** Construção de tipos

Você pode construir seus próprios tipos. Primeiramente, você pode criar apelidos
ou tipos que são sinônimos.

#+begin_src haskell
type Name  = String
type Color = String

showInfos :: Name -> Color -> String
showInfos name color = "Name: " ++ name ++ ", Color: " ++ color

name :: Name
name = "Robin"
color :: Color
color = "Blue"

main = putStrLn $ showInfos name color
#+end_src

------

Mas isso não protege muito a sua função, tente trocar os dois parâmetros de
lugar e executar o seu programa:

#+begin_src haskell
putStrLn showInfos color name
#+end_src

Essa alteração vai compilar e executar. De fato, você pode trocar Name, Color, e
String em todos os lugares. Para o compilador esses tipos são tratados da mesma
forma, eles são completamente idênticos.

Uma outra forma é criar seu próprio tipo usando a _keyword_ =data=.

#+begin_src haskell
data Name = NameConstr String
data Color = ColorConstr String

showInfos :: Name -> Color -> String
showInfos (NameConstr name) (ColorConstr color) =
      "Name: " ++ name ++ ", Color: " ++ color

name  = NameConstr "Robin"
color = ColorConstr "Blue"
main = putStrLn $ showInfos name color
#+end_src

Agora se você trocar os parâmetros da função =showInfos=, o compilador vai
reclamar! Dessa forma, esse potencial erro você não vai cometer novamente.

Note que os contrutores são funções:

#+begin_src haskell
NameConstr  :: String -> Name
ColorConstr :: String -> Color
#+end_src

A sintaxe da =data= é basicamente:

#+begin_src haskell
data typeName = ConstructorName [types]
  | ConstructorName2 [types]
  | ...
#+end_src

Geralmente se utiliza o mesmo nome para o DataTypeName e DataTypeConstructor.

Exemplo:

#+begin_src haskell
data Complex a = Num a => Complex a a
#+end_src

Você também pode utilizar a sintaxe de hashmaps.

#+begin_src haskell
data DataTypeName = DataConstructor {
  field1 :: [type of field1],
  field2 :: [type of field2],
  field3 :: [type of field3],
  ...
  fieldn :: [type of fieldn]}
#+end_src

E vários acessores são criados para você. Exemplo:

#+begin_src haskell
data Complex a = Num => Complex { real :: a, img :: a }
c = Complex 1.0 2.0
z = Complex { real = 3, img = 4 }
real c ⇒ 1.0
img z ⇒ 4
#+end_src

------

*** Tipos recursivos

Você já encontrou um tipo recursivo: listas. Você pode recriar listas, mas
usando uma sintaxe mais prolixa.

#+begin_src haskell
data List a = Empty | Cons a (List a)
#+end_src

Se você quer ser capaz de mostrar (=Show=), ler (=Read=), testar igualdade
(=Eq=), e fazer comparações (=Ord=) com sua nova estrutura de dados, você pode
avisar o Haskell para derivar as funções apropriadas para você:

#+begin_src haskell
infixr 5 :::
data List a = Nil | a ::: (List a)
  deriving (Show, Read, Eq, Ord)
#+end_src

Quando você adiciona =deriving (Show)= para a sua estrutura de dados, Haskell
cria a função =show= para você. Embreve nós vamos utilizar essa função e você
verá como utilizá-la.

*** COMMENT Arvores

[[file:images/_20210726_160704screenshot.png]]


Vamos explorar outro exemplo padrão: arvores binárias.

#+begin_src haskell
import Data.List
data BinTree a = Empty
  | Node a (BinTree a) (BinTree a) deriving (Show)
#+end_src


Vamos criar uma função que transforma uma lista em uma arvore binaria ordenada.

#+begin_src haskell
treeFromList :: (Ord a) => [a] -> BinTree a
treeFromList [] = Empty
treeFromList (x:xs) = Node x
  (treeFromList (filter (<x) xs))
  (treeFromList (filter (>x) xs))

#+end_src

Veja o quão elegante é essa função:

- uma lista vazia vai ser convertida em uma arvore vazia
- a lista =(x:xs)= vai ser convertida em uma arvore onde:
  + a raiz é =x=
  + a arvore há esquerda é criada por elementos da lista que são estritamente inferior a =x=
  + a arvore há direita é criada por elementos da lista que são estritamente superior a =x=


#+begin_src haskell
main = print $ treeFromList [7,2,4,8]
#+end_src

Você deve obter o seguinte:

#+begin_src haskell
Node 7 (Node 2 Empty (Node 4 Empty Empty)) (Node 8 Empty Empty)
#+end_src

Essa é uma representação útil, mas não muito agradável de uma arvore.


------

Só por diversão, vamos programar uma versão melhor para mostrar arvores. Eu me
diverti bastante fazendo uma função interessante para mostrar arvores de uma
forma geral. Você pode pular essa parte se você achar muito difícil de seguir.

Nós temos que fazer algumas poucas mudanças. Vamos remover o =deriving (Show)=
da declaração do nosso tipo =BinTree=. E vai ser útil tornar a nossa BinTree uma
instancia de (=Eq= e =Ord=) para que possamos testar igualdades e comparar
arvores.

#+begin_src haskell
data BinTree a = Empty
  | Node a (BinTree a) (BinTree a)
  deriving (Eq, Ord)
#+end_src

Sem =deriving (Show)=, Haskell não vai criar a função =show= para nós. Nós vamos
criar nossa própria versão de =show=. Para alcançar isso, nós precisamos
declarar que nosso tipo =BinTree= é uma instancia da classe =Show=. A sintax é:

#+begin_src haskell
instance Show (BinTree a) where
  show t = ...  --- Você pode declarar a sua função aqui
#+end_src

Essa é a minha versão sobre como mostrar arvores binarias. Não se preocupe com a
complexidade aparente, eu fiz várias melhorias para conseguir mostrar até
objetos bem estranhos.

#+begin_src haskell
-- declare BinTree a to be an instance of Show
instance (Show a) => Show (BinTree a) where
  -- will start by a '<' before the root
  -- and put a : a begining of line
  show t = "< " ++ replace '\n' "\n: " (treeshow "" t)
    where
    -- treeshow pref Tree
    --   shows a tree and starts each line with pref
    -- We don't display the Empty tree
    treeshow pref Empty = ""
    -- Leaf
    treeshow pref (Node x Empty Empty) =
                  (pshow pref x)

    -- Right branch is empty
    treeshow pref (Node x left Empty) =
                  (pshow pref x) ++ "\n" ++
                  (showSon pref "`--" "   " left)

    -- Left branch is empty
    treeshow pref (Node x Empty right) =
                  (pshow pref x) ++ "\n" ++
                  (showSon pref "`--" "   " right)

    -- Tree with left and right children non empty
    treeshow pref (Node x left right) =
                  (pshow pref x) ++ "\n" ++
                  (showSon pref "|--" "|  " left) ++ "\n" ++
                  (showSon pref "`--" "   " right)

    -- shows a tree using some prefixes to make it nice
    showSon pref before next t =
                  pref ++ before ++ treeshow (pref ++ next) t

    -- pshow replaces "\n" by "\n"++pref
    pshow pref x = replace '\n' ("\n"++pref) (show x)

    -- replaces one char by another string
    replace c new string =
      concatMap (change c new) string
      where
          change c new x
              | x == c = new
              | otherwise = x:[] -- "x"
#+end_src

A função =treeFromList= permanece identica e agora podemos fazer o print da
estrutura.

#+begin_src haskell
main = do
  putStrLn "Int binary tree: "
  print $ treeFromList [7,2,4,8,1,3,6,21,12,23]
#+end_src

#+begin_src shell
Int binary tree:
< 7
: |--2
: |  |--1
: |  `--4
: |     |--3
: |     `--6
: `--8
:    `--21
:       |--12
:       `--23
#+end_src

Agora está bem melhor!! A raiz é identificada pelo uso do caractere =<= no
inicio da linha e cada linha subsequente começa com =:=. Mas nós também podemos
utilizar essa estrutura com outros tipos:

#+begin_src haskell
  putStrLn "\nString binary tree:"
  print $ treeFromList ["foo","bar","baz","gor","yog"]
#+end_src

#+begin_src shell
String binary tree:
< "foo"
: |--"bar"
: |  `--"baz"
: `--"gor"
:    `--"yog"
#+end_src

Dado que agora podemos testar igualdade e comparar arvores, nós também podemos
criar arvores dentro de arvores!

#+begin_src haskell
  putStrLn "\nBinary tree of Char binary trees:"
  print ( treeFromList
           (map treeFromList ["baz","zara","bar"]))
#+end_src

#+begin_src shell
Binary tree of Char binary trees:
< < 'b'
: : |--'a'
: : `--'z'
: |--< 'b'
: |  : |--'a'
: |  : `--'r'
: `--< 'z'
:    : `--'a'
:    :    `--'r'
#+end_src

Esse é o motivo que eu escolhi utilizar o prefixo de cada linha com =:= (exceto
a raiz)

[[file:images/_20210726_201437screenshot.png]]

#+begin_src haskell
 putStrLn "\nTree of Binary trees of Char binary trees:"
  print $ (treeFromList . map (treeFromList . map treeFromList))
             [ ["YO","DAWG"]
             , ["I","HEARD"]
             , ["I","HEARD"]
             , ["YOU","LIKE","TREES"] ]
#+end_src

É o equivalente a:

#+begin_src haskell
print ( treeFromList (
          map treeFromList
             [ map treeFromList ["YO","DAWG"]
             , map treeFromList ["I","HEARD"]
             , map treeFromList ["I","HEARD"]
             , map treeFromList ["YOU","LIKE","TREES"] ]))
#+end_src

que resulta em:

#+begin_src shell
Binary tree of Binary trees of Char binary trees:
< < < 'Y'
: : : `--'O'
: : `--< 'D'
: :    : |--'A'
: :    : `--'W'
: :    :    `--'G'
: |--< < 'I'
: |  : `--< 'H'
: |  :    : |--'E'
: |  :    : |  `--'A'
: |  :    : |     `--'D'
: |  :    : `--'R'
: `--< < 'Y'
:    : : `--'O'
:    : :    `--'U'
:    : `--< 'L'
:    :    : `--'I'
:    :    :    |--'E'
:    :    :    `--'K'
:    :    `--< 'T'
:    :       : `--'R'
:    :       :    |--'E'
:    :       :    `--'S'
#+end_src

Note como arvores duplicadas não são inseridas; existe somente uma arvore
correspondendo a ="I", "HEARD"=. Nós ganhamos isso (quase) de graça porque nós
definimos o tipo BinTree para ser uma instância de =Eq=.

Perceba o quão legal essa estrutura é: Nós podemos criar arvores contendo
inteiros, strings, chars, e também outras arvores.


*** Estruturas infinitas

[[file:images/_20210725_195405screenshot.png]]

É comum falar que Haskell é _preguiçoso_.

De fato, se você quiser bem preciso, você deveria dizer que Haskell é
não-estrito. =Laziness= é somente uma implementação comum de linguagens
não-estritas.

Dessa forma, o que "não-estrita" significa? Diretamente do Haskell wiki:

#+begin_quote
Redução (o termo matemático para avaliação) procede de fora para dentro.

Assim, se você tem =(a+(b*c))= então você deve primeiro reduzir =+= primeiro,
depois reduzir a expressão interna =(b*c)=.
#+end_quote

Por exemplo, nós podemos fazer o seguinte em Haskell:

#+begin_src haskell
-- numbers = [1,2,..]
numbers :: [Integer]
numbers = 0:map (1+) numbers

take' n [] = []
take' 0 l = []
take' n (x:xs) = x:take' (n-1) xs

main = print $ take' 10 numbers
#+end_src

E isso vai parar em algum momento.

Como?

No lugar de tentar avaliar =numbers= por inteiro, o compilador vai avaliar os
elementos somente quando necessario.

Note também que em Haskell existe uma notação para listas infinitas:

#+begin_src haskell
[1..]   ⇔ [1,2,3,4...]
[1,3..] ⇔ [1,3,5,7,9,11...]
#+end_src

e a maioria das funções vão funcionar sobre essas estruturas.

-------

Suponha que não nos importamos em ter uma arvore binaria ordenada, segue a
definição de uma arvore binaria infinita:

#+begin_src haskell
nullTree = Node 0 nullTree nullTree
#+end_src

Uma arvore binaria completa onde cada nó é igual a 0.

Agora eu vou provar para você que nós podemos manipular esse objeto usando a
seguinte função:

#+begin_src haskell
-- take all element of a BinTree
-- up to some depth
treeTakeDepth _ Empty = Empty
treeTakeDepth 0 _     = Empty
treeTakeDepth n (Node x left right) = let
          nl = treeTakeDepth (n-1) left
          nr = treeTakeDepth (n-1) right
          in
              Node x nl nr
#+end_src

Veja o que acontece com esse programa:

#+begin_src haskell
main = print $ treeTakeDepth 4 nullTree
#+end_src

Esse código compila, executa e para fornecendo o seguinte resultado:

#+begin_src shell
<  0
: |-- 0
: |  |-- 0
: |  |  |-- 0
: |  |  `-- 0
: |  `-- 0
: |     |-- 0
: |     `-- 0
: `-- 0
:    |-- 0
:    |  |-- 0
:    |  `-- 0
:    `-- 0
:       |-- 0
:       `-- 0
#+end_src

Só para esquentar seus neurônios mais um pouco, vamos fazer uma arvore um pouco
mais interessante:

#+begin_src haskell
iTree = Node 0 (dec iTree) (inc iTree)
  where
    dec (Node x l r) = Node (x-1) (dec l) (dec r)
    inc (Node x l r) = Node (x+1) (inc l) (inc r)
#+end_src

Uma outra forma de criar essa arvore seria utilizando funções de ordem elevada.
Essa função deveria ser similar ao =map=, mas deveria funcionar em =BinTree= no
lugar de apenas em listas. Segue tal função:

#+begin_src haskell
--- aplica a função para cada nó da Arvore
treeMap :: (a -> b) -> BinTree a -> BinTree b
treeMap f Empty = Empty
treeMap f (Node x left right) = Node (f x)
                                (treeMap f left)
                                (treeMap f right)
#+end_src

Dica: eu não vou falar mais sobre isso aqui, mas se você está interessado em
generalizações da função =map= para outras estruturas de dados, pesquise por
=functor= e =fmap=.

Nossa definição agora é:

#+begin_src haskell
infTreeTwo :: BinTree Int
infTreeTwo = Node 0 (treeMap (\x -> x-1) infTreeTwo)
                    (treeMap (\z -> x+1) infTreeTwo)
#+end_src

Veja o resultado para a seguinte chamada:

#+begin_src haskell
main = print $ treeTakeDepth 4 infTreeTwo
#+end_src

#+begin_src haskell
<  0
: |-- -1
: |  |-- -2
: |  |  |-- -3
: |  |  `-- -1
: |  `-- 0
: |     |-- -1
: |     `-- 1
: `-- 1
:    |-- 0
:    |  |-- -1
:    |  `-- 1
:    `-- 2
:       |-- 1
:       `-- 3
#+end_src


* Nível de dificuldade - HELL

Parabéns por chegar até aqui! Agora, nós precisamos entrar em uma parte
realmente complicado.

Se você é como eu, você deve entender o estilo funcional. Você deve também
entender um pouco mais sobre as vantagens de =laziness= por padrão, mas você não
entende de verdade por onde começar quando você precisa escrever um programa
real. E em particular:

- Como você lida com efeitos?
- Por que existe essa noção estranha inspirada em programação imperativa para lidar com IO?

Se prepare, as respostas podem ser um pouco complexas, mas elas são todas
bastante recompensadoras.

** Lidando com IO

[[file:images/_20210725_211341screenshot.png]]

#+begin_quote
tl;dr:

Uma função fazendo =IO= parece com um programa tipicamente imperativo:
#+begin_src haskell
f :: IO a
f = do
  x <- action1
  action2 x
  y <- action3
  action4 x y
#+end_src

- para definir um valor em um objeto nós usamos =<-=
- o tipo de cada linha no próximo exemplo é =IO *=;
  - =action1 ::: IO b=
  - =action2 x ::: IO ()=
  - =action3 ::: IO c=
  - =action4 x y ::: IO a=
  - =x ::: b=, =y ::: c=
- poucos objetos tem o tipo =IO a=, isso deveria ajudar você a escolher. Em
  particular você não pode usar funções puras diretamente nesses casos. Para
  usar uma função pura, você poderia fazer =action2 (purefunction x)= por
  exemplo.

Aviso: Por causa de algum problema no markdown Github, eu precisei utilizar o
simbolo =:::= no lugar de =::= acima.

#+end_quote

Nessa seção, eu vou explicar como usar IO, não como ele funciona. Você vai ver
como Haskell separa as funções puras das partes impuras do seu programa.

Não pare porque você está tentando entender os detalhes da sintaxe, as respostas
vão chegar nas próximas seções.

O que vamos fazer?

#+begin_quote
Pergunte ao usuário para entrar uma lista de números. Exiba a soma desses
números.
#+end_quote

#+begin_src haskell
toList :: String -> [Integer]
toList input = read ("[" ++ input ++ "]")

main = do
  putStrLn = "Entre uma lista de numeros (separados por virgula)"
  input <- getLine
  print $ sum (toList input)
#+end_src

Deve ser simples entender o comportamento desse programa. Vamos analizar os
tipos com mais detalhes.

#+begin_src haskell
putStrLn :: String -> IO ()
getLine :: IO String
print :: Show a => a -> IO ()
#+end_src


Mais interessante ainda, note que cada expressão dentro do bloco =do= tem o tipo
de =IO a=

#+begin_src haskell
main = do
  putStrLn "Entre ..." :: IO ()
  getLine              :: IO String
  print Alguma coisa   :: IO ()
#+end_src

Também devemos prestar atenção aos efeitos do simbolo =<-=
#+begin_src haskell
do
  x <- alguma-coisa
#+end_src

Se =alguma-coisa :: IO a= então =x :: a=.

Outra coisa importante sobre o u so de =IO=: Todas as linhas dentro do bloco
=do= devem ter uma de duas formas possíveis:

#+begin_src haskell
action1           :: IO a
                     --- nesse caso, geralmente a = ()
#+end_src

ou

#+begin_src haskell
valor <- action2     -- onde
                     -- action2 :: IO b
                     -- valor :: b
#+end_src

Essas duas formas de expressar IO vão implicar em formas diferentes de
sequenciar ações no futuro. O significado disso vai ficar mais claro no final da
próxima seção.

--------

Agora vamos ver como esse programa se comporta. Por exemplo, o que acontece caso
o usuário digite alguma coisa sem sentido? Vamos tentar:

#+begin_src haskell
 % runghc 02_progressive_io_example.lhs
    Enter a list of numbers (separated by comma):
    foo
    Prelude.read: no parse
#+end_src

Argh!! Uma mensagem de erro do mau e o programa quebrou! Nossa primeira melhoria
vai ser simplesmente responder com uma mensagem mais amigável caso o usuário
faça isso novamente.

Para conseguir fazer isso, nós temos que ser capaz de detectar que algo deu
errado. Uma outra forma de fazer isso é utilizar o tipo =Maybe=, esse é um tipo
de dado bem comum em Haskell.

#+begin_src haskell
import Data.Maybe
#+end_src

Mas o que é esse tipo =Maybe=? É um tipo que recebe apenas um parâmetro e sua
definição é:

#+begin_src haskell
data Maybe a = Nothing | Just a
#+end_src

Essa é uma forma bem legal de detectar se houve um erro enquanto tentamos criar
ou calcular um determinado valor. A função =maybeRead= é um bom exemplo disso,
essa função é bem similar ao =read= mas se alguma coisa der errado ela vai
retornar o valor =Nothing= e caso dê tudo certo, vai retornar o valor =Just <o
valor>=.

Não gaste muito tempo tentando entender tudo sobre essa função por enquanto.

#+begin_src haskell
maybeRead :: Read a => String -> Maybe a
maybeRead s = case reads s of
                [(x, "")] -> Just x
                _         -> Nothing
#+end_src

Agora um pouco mais legível, vamos escrever uma função da seguinte forma: Caso a
string tenha o formato errado, vamos retornar =Nothing=, mas caso a entrada
tenha o valor correto, por exemplo "1,2,3", vamos retornar =Just [1,2,3]=.

#+begin_src haskell
getListFromString :: String -> Maybe [Integer]
getListFromString str = maybeRead $ "[" ++ str ++ "]"
#+end_src

Agora basta testarmos o valor no nosso programa principal:

#+begin_src haskell
main :: IO ()
main = do
  putStrLn "Entre uma lista de numeros (separados por virgula):"
  input <- getLine
  let maybeList = getListFromString input in
    case maybeList of
      Just l -> print (sum l)
      Nothing -> error "Formato errado. Adeus!"
#+end_src

Em caso de erro, nós retornamos uma mensagem de erro amigável.

Note que o tipo de cada uma das expressões dentro do bloco principal =do=
permanece sendo =IO a=. A única parte esquisita é o =error=. Eu vou apenas dizer
aqui que o =error msg= tem o tipo necessário para o que precisamos (=IO ()=).

Uma coisa muito importante para perceber é o tipo de todas as funções definidas
até agora. Existe apenas uma função que tem =IO= em seu tipo: =main=. Isso
significa que =main= não é pura, mas usa a função =getListFromString= que é
pura. Portanto, fica claro apenas olhando para as definições dos tipos quais são
as funções puras ou não.

Por que esse característica de ser pura importa? Dentre outras vantagens podemos listar:
- é mais fácil pensar sobre funções puras do que impuras
- funções puras te protegem de todos os erros no seu sistema que são difíceis de
  reproduzir devido a efeitos-colaterais
- você pode avaliar funções puras em qualquer ordem ou em parallel sem nenhum risco.

Esses são alguns dos motivos pelos quais você deveria colocar tanto código
quanto for possível dentro de funções puras.

------

Nossa próxima iteração vai ser perguntar ao usuário varias e varias vezes até
que ele informe entradas válidas.

Vamos manter a primeira parte:

#+begin_src haskell
import Data.Maybe

maybeRead :: Read a => String -> Maybe a
maybeRead s = case reads s of
                  [(x,"")]    -> Just x
                  _           -> Nothing
getListFromString :: String -> Maybe [Integer]
getListFromString str = maybeRead $ "[" ++ str ++ "]"
#+end_src

Agora nós criamos uma função que vai perguntar usuário pela lista de inteiros
até que ele entre corretamente.

#+begin_src haskell
askUser :: IO [Integer]
askUser = do
  putStrLn "Entre uma lista de numeros (separados por virgula):"
  input <- getLine
  let maybeList = getListFromString input in
    case maybeList of
      Just l -> return l
      Nothing -> askUser
#+end_src

Essa função é do tipo =IO [Integer]= e significa que nós receber o valor do tipo
=[Integer]= através alguma ação de IO. Algumas pessoas diriam:

#+begin_quote
Isso é um =[Integer]= dentro de =IO=
#+end_quote

Se você quer entender os detalhes por trás de tudo isso, você vai ter que ler a
próxima seção, mas a realidade é que se você só quer *usar* o IO, pratique um
pouco e se lembre de pensar sobre os tipos.

Finalmente, nossa função principal é muito mais simples agora:

#+begin_src haskell
main :: IO ()
main = do
  list <- askUser
  print $ sum list
#+end_src

Nós terminamos aqui com a nossa introdução sobre =IO=. Foi um pouco rápido!
Essas são as principais coisas para se lembrar:

- dentro do bloco =do=, cada expressão precisa ter um tipo =IO a=. Sendo assim
  você fica limitado a quantidade de expressões disponíveis, por exemplo,
  =getLine=, =print=, =putStrLn=, etc...
- tente mover as funções puras para fora desse bloco o máximo possível
- o tipo =IO= significa: uma ação IO que retorna um elemento do tipo =a=. =IO=
  representa ações, por debaixo dos panos, =IO= é o tipo de uma função, mas leia
  a próxima seção se você está curioso.

Se você praticar um pouco, você vai ser capaz de *usar* =IO=.

#+begin_quote
Exercício:
- Faça um programa que some todos os argumentos. Dica: use a função =getArgs=.
#+end_quote

** Explicando truques com IO

[[file:images/_20210725_211405screenshot.png]]

#+begin_quote
tl;dr:

Para separar partes puras e impuras, =main= é definida como uma função que
modifica o estado do mundo externo.

#+begin_src haskell
main :: World -> World
#+end_src

A função tem garantia de conter efeitos colaterais somente se tiver esse tipo,
mas veja como é uma função main tipica.

#+begin_src haskell
main w0 =
  let (v1, w1) = action1 w0 in
  let (v2, w2) = action2 v1 w1 in
  let (v3, w3) = action3 v2 w2 in
  action4 v3 w3
#+end_src

Nós temos vários elementos temporários sendo criados nesse exemplo (=w1=, =w2=,
e =w3=) que deve ser passado para a próxima ação.

Nós criamos uma função chamada =bind= ou (=>>==), com o =bind= nós não
precisamos de nomes temporários mais:

#+begin_src haskell
main =
  action1 >>= action2 >>= action3 >>= action4
#+end_src

Extra: Haskell tem uma sintaxe mais fácil para fazer o =bind=

#+begin_src haskell
main = do
  v1 <- action1
  v2 <- action2 v1
  v3 <= action3 v2
  action4 v3
#+end_src

#+end_quote

Por que nós usamos essa sintaxe estranha e o que é exatamente esse tipo =IO=?
Parece um pouco como mágica.

Por enquanto vamos esquecer todas as partes puras do nosso sistema e focar na
parte impura:

#+begin_src haskell
askUser :: IO [Integer]
askUser = do
  putStrLn "Entre uma lista de numeros (separados por virgula): "
  input <- getLine
  let maybeList = getListFromString input in
    case maybeList of
      Just l -> return l
      Nothing -> askUser

main :: IO ()
main = do
  list <- askUser
  print $ sum list
#+end_src

Primeira impressão: Esse código parece imperativo. Haskell é expressivo o
suficiente para fazer código impuro parecer imperativo, por exemplo, se você
deseja criar um =while= em Haskell é possível. De fato, para lidar com =IO= o
estilo imperativo é geralmente o mais apropriado.

Mas você deve ter notado que a notação é um pouco não usual. Em uma linguagem
impura, o estado do mundo externo pode ser entendido como uma grande variável
estado global escondida. Essa variável escondida é acessível por todas as
funções da sua linguagem. Por exemplo, você pode ler ou escrever em um arquivo
de dentro de qualquer função. O fato do arquivo existir ou não é a diferença
entre possíveis estados que o mundo externo pode ter.

Em Haskell, o estado atual do mundo externo não está escondido. Pelo contrário,
o estado é *explicitamente* declarado e dizemos que =main= é uma função que
*potencialmente* troca o estado do mundo externo. Portanto, o tipo de =main=
seria algo como:

#+begin_src haskell
main :: World -> World
#+end_src

Não são todas as funções que precisam ter acesso a essa variavel. As funções que
tem acesso são as impuras.

Haskell considera o estado do mundo externo como uma variável de entrada da
função =main=, mas o tipo verdadeiro de =main= está mais próximo de:

#+begin_src haskell
main :: World -> ((), World)
#+end_src

O =()= é o tipo unitário. Nada demais aqui.

Agora vamos re-escrever nossa função principal com isso em mente:

#+begin_src haskell
main w0 =
  let (list, w1) = askUser w0 in
  let (x, w2) = print (sum list, w1) in
  x
#+end_src

Primeiro, notamos que todas as funções com efeitos colaterais precisam ter o tipo:

#+begin_src haskell
World -> (a, World)
#+end_src

onde =a= é o tipo do resultado. Por exemplo, a função =getChar= deveria ter o
tipo =World -> (Char, World)=.

Outra coisa interessante é o truque para concertar a ordem de avaliação. Em
Haskell, para avaliar =f a b= você tem diversas opções:

- primeiro avaliar =a=, depois =b=, depois =f a b=
- primeiro avaliar =b=, depois =a=, depois =f a b=
- avaliar =a= e =b= em paralelo e depois =f a b=

Isso é verdadeiro porque nós estamos trabalho na parte pura da linguagem.

Agora, se você olhar para a função principal =main= fica claro que você precisa
avaliar a primeira linha antes da segunda porque para avaliar a segunda linha
você depende de um parâmetro que é dado pela primeira linha.

O compilador vai apontar para uma nova versão do mundo externo, por trás dos
panos o =print= vai funcionar da seguinte forma:

- mostre alguma coisa na tela
- modifique o id que referencia o mundo externo
- calcule como =((), novo mundo externo id)=

Agora, se você olhar para o estilo da função principal, é claramente esquisito.
Vamos fazer a mesma coisa com a função =askUser=:

#+begin_src haskell
askUser :: World -> ([Integer], World)
#+end_src

Antes:

#+begin_src haskell
askUser :: IO [Integer]
askUser = do
  putStrLn "Entre uma lista de numeros:"
  input <- getLine
  let maybeList = getListFromString input in
    case maybeList of
      Just l -> return l
      Nothing -> askUser
#+end_src


Depois:
#+begin_src haskell
askUser w0 =
  let (_, w1)     = putStrLn "Entre uma lista de numeros:" in
  let (input, w2) = getLine w1 in
  let (l, w3)     = case getListFromString input of
                      Just l -> (l, w2)
                      Nothing -> askUser w2
  in
    (l, w3)
#+end_src


Isso é similar, mas estranho, veja todos essas variáveis temporárias =w?=.

A lição aqui é clara: Implementações simplificadas de IO em linguagens puramente
funcionais é estranho!

Felizmente existe uma forma melhor de tratar esse problema. Vamos ver um padrão,
cada linha acima tem a seguinte forma:

#+begin_src haskell
let (y, w')  = action x w in
#+end_src

Mesmo que para algumas linhas o primeiro argumento =x= não seja necessário. O
tipo do resultado é =(resposta, novoMundo)= logo cada função =f= deve ter o tipo:

#+begin_src haskell
f :: World -> (a, World)
#+end_src

Ou seja, estamos seguindo sempre o mesmo padrão abaixo

#+begin_src haskell
let (y, w1) = action w0 in
let (z, w2) = action w1 in
let (t, w3) = action w2 in
...
#+end_src

E cada ação (=action=) pode conter de 0 a =n= parâmetros e em particular eles
podem receber um parâmetro vindo da linha anterior:

#+begin_src haskell
let (_,w1) = action1 x w0   in
let (z,w2) = action2 w1     in
let (_,w3) = action3 z w2 in
...
#+end_src


[[file:images/_20210727_122926screenshot.png]]


Agora vamos fazer um truque de mágica! Nós vamos os simbolos temporarios dos
mundos externos =w?= "desaparecerem". Nós vamos usar =bind= nas duas linhas.

Vamos definir a função =bind=, note que o seu tipo pode ser bem intimidador de
inicio:

#+begin_src haskell
bind :: (World -> (a, World))
       -> (a -> (World -> (b, World)))
       -> (World -> (b, World))
#+end_src

Mas se lembre que =(World -> (a, World))= é o tipo de uma ação IO, vamos
renomear isso para deixar mais claro.

#+begin_src haskell
type IO a = World -> (a, World)
#+end_src

Alguns exemplos de funções:

#+begin_src haskell
getLine :: IO String
print :: Show a => a -> IO ()
#+end_src

=getLine= é uma ação IO que recebe o mundo externo como um parâmetro e retorna
alguns =(String, World)=. Isso pode ser resumido falando que =getLine= tem o
tipo =IO String=

A função =print= também é interessante. Ela recebe um argumento que possa ser
mostrado na tela. De fato, ela recebe dois argumentos. O primeiro é o valor que
vai ser mostrado e o segundo é o estado do mundo externo. Depois retorna algo
com tipo =((), World))= que significa que a função alterou o estado do mundo
externo mas não produziu nenhum resultado de retorno.

Esse noto tipo =IO a= nos ajuda a simplificar o tipo do =bind=:

#+begin_src haskell
bind :: IO a
        -> (a -> IO b)
        -> IO b
#+end_src

Isso quer fizer que o =bind= recebe duas ações de IO como parametros e retorna
outra ação de IO.

Agora, lembre-se do padrão importante que tinhamos notado. De inicio era:

#+begin_src haskell
pattern1  w0 =
  let (x, w1) = action1 w0 in
  let (y, w2) = action2 x w1 in
  (y, w2)
#+end_src

Veja os tipos:

#+begin_src haskell
action1   :: IO a
action2   :: a -> IO b
pattern1  :: IO b
#+end_src

Não parece familiar?

#+begin_src haskell
(bind action1 action2) w0 =
  let (x, w1) = action1 w0
      (y, w2) = action2 x w1
  in  (y, w2)
#+end_src

A ideia aqui é esconder as variáveis que correspondem ao mundo externo. Vamos
lá: Como um exemplo, imagine que você queira simular o seguinte:

#+begin_src haskell
let (line1, w1) = getLine w0 in
let ((), w2)    = print line1 in
  ((), w2)
#+end_src

Agora, usando a função =bind=

#+begin_src haskell
(res, w2) = (bind getLine print) w0
#+end_src

Como o =print= é do tipo =Show a => a -> (World, ((), World))=, nós sabemos que
=res = ()= (tipo =unit=). Se você não conseguiu ver a mágica aqui, vamos tentar
com essas três linhas agora:

#+begin_src haskell
let (line1, w1) = getLine w0 in
let (line2, w2) = getLine w1 in
let ((), w3)    = print (line1 ++ line2 ) in
  ((), w3)
#+end_src

Que é equivalente a:

#+begin_src haskell
(res, w3) = (bind getLine (\line1 ->
                             (bind getLine (\line2 ->
                                              print (line1 ++ line2))))) w0
#+end_src

Não reparou em algo? Nenhuma variável do mundo externo é usada em lugar algum.
Isso é má-gi-ca!

Nós podemos utilizar uma notação melhor. Vamos usar =>>== no lugar de =bind=. A
função =>>== é uma função infixa igual ao =(+)= ou seja =3 + 4 <-> (+) 3 4=

#+begin_src haskell
(res, w3) = (getLine >>=
            (\line1 -> getLine >>=
            (\line2 -> print (line1 ++ line2)))) w0
#+end_src

Para nossa sorte, o Haskell tem uma sintaxe legal para isso:

#+begin_src haskell
do
  x <- action1
  y <- action2
  z <- action3
  ...
#+end_src

É trocado por:

#+begin_src haskell
action1 >>= (\x ->
action2 >>= (\y ->
action3 >>= (\z ->
...
)))
#+end_src

Note que você pode usar =x= na =action2= e =x= e =y= na =action3=.

Mas e as linhas que não estão usando =<-=? Como elas ficam? Fácil, basta criar
uma outra função chamada =blindBind=:

#+begin_src haskell
blindBind :: IO a -> IO b -> IO b
blindBind action1 action2 w0 =
  bind action1 (\_ -> action2) w0
#+end_src

Eu não simplifiquei essa definição para deixá-la mais clara, porém nós podiamos
ter usado uma notação melhor: =>>=

e

#+begin_src haskell
do
  action1
  action2
  action3
#+end_src

é transformado em
#+begin_src haskell
action1 >>
action2 >>
action3
#+end_src

Uma outra função bem util é essa aqui:

#+begin_src haskell
putInIO :: a -> IO a
putInIO x = IO (\w -> (x, w))
#+end_src

Essa é uma forma de colocar valores puros dentro de um contexto de IO. O nome
geral dado em Haskell para a função =putInIO= é o =return= (esse nome é bem ruim
em Haskell porque o conceito de =return= aqui é bem diferente do que você
normalmente usa em outras linguagens)

------

Para finalizar, vamos traduzir o nosso exemplo:

#+begin_src haskell
askUser :: IO [Integer]
askUser = do
  putStrLn "Enter a list of numbers (separated by commas):"
  input <- getLine
  let maybeList = getListFromString input in
      case maybeList of
          Just l  -> return l
          Nothing -> askUser

main :: IO ()
main = do
  list <- askUser
  print $ sum list
#+end_src

para

#+begin_src haskell
import Data.Maybe

maybeRead :: Read a => String -> Maybe a
maybeRead s = case reads s of
                  [(x,"")]    -> Just x
                  _           -> Nothing
getListFromString :: String -> Maybe [Integer]
getListFromString str = maybeRead $ "[" ++ str ++ "]"
askUser :: IO [Integer]
askUser =
    putStrLn "Enter a list of numbers (sep. by commas):" >>
    getLine >>= \input ->
    let maybeList = getListFromString input in
      case maybeList of
        Just l -> return l
        Nothing -> askUser

main :: IO ()
main = askUser >>=
  \list -> print $ sum list
#+end_src


** Monads


[[file:images/_20210725_211428screenshot.png]]

** A lista monad


[[file:images/_20210725_211442screenshot.png]]


* Anexo

** Mais sobre Arvore Infinita
