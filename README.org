* Aprenda Haskell Rápido e Difícil :TOC_3_gh:
  - [[#exploda-sua-cabeça-com-haskell][Exploda sua cabeça com Haskell]]
- [[#introdução][Introdução]]
  - [[#instalação][Instalação]]
  - [[#não-tenha-medo][Não tenha medo]]
  - [[#haskell-muito-básico][Haskell muito básico]]
    - [[#um-exemplo-usando-tipos][Um exemplo usando Tipos]]

** Exploda sua cabeça com Haskell

[[file:images/_20210725_102116screenshot.png]]

Um tutorial pequeno e denso para aprender Haskell.

Eu realmente acredito que todos os desenvolvedores deveriam aprender Haskell. Eu
não acho que todo mundo precisa ser super Haskell ninjas, mas que pelo menos
pudessem descobrir o que o Haskell tem para oferecer.

Aprender Haskell abre sua mente.

As linguagens de programação mais utilizadas compartilham as mesmas fundações:

- variáveis
- _loops_
- ponteiros
- estruturas de dados, objetos e classes

Haskell é bem diferente. A linguagem usa vários conceitos que eu nunca tinha
ouvido falar antes. Muitos desses conceitos vão ajudar você a se tornar um
programador melhor.

Mas aprender Haskell pode ser bem difícil. Foi assim pra mim. Nesse artigo eu
tento passar o que faltou pra mim enquanto eu aprendia Haskell.

Esse artigo vai ser difícil de ser seguido. Isso é proposital. Não há atalhos
para aprender Haskell. É difícil e desafiador, mas eu acredito que isso é uma
coisa boa.

O método convencional para aprender Haskell se resume em ler dois livros.
Primeiro, "[[http://learnyouahaskell.com/][Learn You a Haskell]]" e depois "[[http://book.realworldhaskell.org][Real World Haskell]]". Eu acredito que
essa é a melhor forma de fato, mas para aprender do que se trata Haskell de
verdade, você precisa ler esses livros nos detalhes.

Em contrapartida, esse artigo é uma visão geral bem resumida e densa de todas os
aspectos gerais de Haskell. Eu também adicionei algumas informações que eu não
tinha quando eu aprendi Haskell.

O artigo contém 5 partes:

1. Introdução: breve exemplo para mostrar que Haskell pode ser amigável
2. Haskell básico: sintaxe e algumas noções essenciais
3. Nível de dificuldade - *HARD*:
   a. Estilo funcional: um exemplo progressivo do estilo imperativo para o funcional
   b. Tipos: tipos e exemplo de uma arvore binaria
   c. Sequencias infinitas: manipular uma arvore binaria infinita
4. Nível de dificuldade - *HELL*
   a. Lidando com IO: um pequeno exemplo
   b. Explicando truques envolvendo IO: os detalhes escondidos para entender IO
   c. _Monads_: generalizações incríveis
5. Anexo
   a. Mais sobre arvores infinitas: uma discussão mais orientada usando matemática

#+begin_quote
 Nota: Toda vez que você encontrar um separador com um arquivo terminando em
  =.lhs= você pode clicar no nome do arquivo e fazer o download. Se você salvar
  o arquivo como =filename.lhs=, você pode rodar ele com:
  #+begin_src shell
runhaskell filename.lhs
  #+end_src
#+end_quote


* Introdução
** Instalação

[[file:images/_20210725_105352screenshot.png]]

Existem diferentes formas para instalar o Haskell, eu recomendo utilizar o
[[https://docs.haskellstack.org/en/stable/README/][stack]]. As outras formas de instalar Haskell vão depender bastante do seu
sistema, você pode aprender mais sobre isso visitando [[https://www.haskell.org][haskell.org]] ou
[[https://www.fpcomplete.com/haskell/][haskell-lang.org]].

Ferramentas:
- =ghc=: Compilador similar ao gcc para =C=
- =ghci=: Haskell Interativo (REPL)
- =runhaskell=: Execute um programa sem compilar ele. Bastante conveniente, mas
  é bem mais lento do que executar o programa compilado.

#+begin_quote
Nota{Wand}: Caso você use o Emacs, recomendo o [[https://github.com/hlissner/doom-emacs][Doom]] emacs e basta habilitar
  a camada de Haskell +lsp.
#+end_quote


** Não tenha medo

[[file:images/_20210725_105402screenshot.png]]

Muitos livros e artigos sobre Haskell iniciam com alguma formula esotérica
(quicksort, Fibonacci, etc). Eu vou pelo extremo oposto. De inicio não vou te
mostrar nenhum super poder do Haskell. Eu vou iniciar com as similaridades entre
Haskell e outras linguagens de programação. Vamos começar com o obrigatório
"Hello World".

#+begin_src haskell
main = putStrLn "Hello World!"
#+end_src

Para rodar, você precisa salvar esse código em um arquivo =hello.hs= e:

#+begin_src shell
~ runhaskell ./hello.hs
Hello World!
#+end_src

ou se você estiver usando =stack=, primeiro rode =stack setup= e depois:

#+begin_src shell
~ stack runhaskell ./hello.hs
Hello World!
#+end_src

-------

Agora vamos criar um programa perguntando pelo seu nome e respondendo "Hello"
usando o nome que você forneceu:

#+begin_src haskell
main = do
  print "What is your name?"
  name <- getLine
  print ("Hello " ++ name ++ "!")
#+end_src

Vamos comparar como esse programa seria implementado em algumas linguagens
imperativas:

#+begin_src python
# Python

print "What is your name?"
name = raw_input()
print "Hello %s!" % name
#+end_src

#+begin_src ruby
# Ruby

puts "What is your name?"
name = gets.chomp
puts "Hello #{name}!"
#+end_src

#+begin_src c
// In C

#include <stdio.h>
int main (int argc, char **argv) {
    char name[666]; // <- An Evil Number!
    // What if my name is more than 665 character long?
    printf("What is your name?\n");
    scanf("%s", name);
    printf("Hello %s!\n", name);
    return 0;
}
#+end_src

A estrutura é a mesma, mas existem algumas diferenças de sintaxe. A principal
parte desse tutorial vai ser dedicada a explicar o por quê.

Em Haskell existe a função =main= e todos os objetos tem um =tipo=. O tipo da
função =main= é =IO()=. Isso significa que =main= vai causar algum efeito
colateral.

Lembre-se que Haskell pode se parecer bastante com linguagens de programação
mais comuns.

** Haskell muito básico

[[file:images/_20210725_105419screenshot.png]]

Antes de continuar, você precisa ser avisado sobre algumas propriedades
essenciais do Haskell.


*Funcional*

Haskell é uma linguagem funcional. Se você vem tem experiência com linguagens
imperativas, você vai precisar aprender um monte de coisas novas. Felizmente,
muitos desses novos conceitos vão te ajudar a programar até nas linguagens
imperativas.


*Tipagem Estática Inteligente*

No lugar de te atrapalhar como no caso de =C=, =C++=, ou =Java=, o sistema de
tipos do Haskell tenta o máximo possível te ajudar.


*Pureza*

Geralmente suas funções não vão modificar nada fora seu ambiente de execução.
Isso significa que essas funções não podem modificar valores de variáveis, não
podem pegar valores de entrada de usuários, não podem escrever na sua tela, não
podem lançar misseis. Por outro lado, paralelismo vai ser bem fácil de alcançar.
Haskell deixa muito claro onde os *efeitos* podem ocorrer e onde o seu código é
puro. Dessa forma, vai ser bem mais fácil de racionalizar sobre o seu programa e
a maioria dos bugs vai ser prevenido nas partes puras do seu programa.

Além disso, funções puras seguem uma lei fundamental em Haskell:

#+begin_quote
Aplicar uma função com os mesmos parâmetros vai sempre retornar o mesmo resultado
#+end_quote


*Laziness*

*Laziness* (preguiça) ser o comportamento padrão é bastante incomum em
linguagens de programação. Por padrão, Haskell só vai calcular algo quando for
necessário. Por consequência disso, Haskell também prove uma forma elegante de
manipular estruturas infinitas, por exemplo.

Um ultimo aviso sobre como você deveria ler um código Haskell. Para mim, a
leitura é como se fosse um artigo cientifico. Algumas partes são claras, mas
quando você encontra uma formula, só foque e leia mais devagar. Além disso,
enquanto aprende Haskell, realmente não importa se você não entendeu os detalhes
da sintaxe. Por exemplo, caso encontre um =>>==, =<$>=, =<-= ou qualquer outro
simbolo esquisito, só ignore eles e continue seguindo o fluxo de execução do
código

*** COMMENT Declaração de Funções

Você pode estar acostumado a declarar funções dessa forma:

In C:
#+begin_src c
int f(int x, int y) {
    return x*x + y*y;
}
#+end_src

In JavaScript:
#+begin_src javascript
function f(x,y) {
    return x*x + y*y;
}
#+end_src

In Python:
#+begin_src python
def f(x,y):
    return x*x + y*y
#+end_src

In Ruby:
#+begin_src ruby
def f(x,y)
  x*x + y*y
end
#+end_src

In Scheme:
#+begin_src scheme
(define (f x y)
  (+ (* x x) (* y y)))
#+end_src

Finalmente, em Haskell:
#+begin_src haskell
f x y = x**x + y*y
#+end_src

Bem limpo. Sem parenteses, sem =def=.

Não se esqueça que Haskell usa muito funções e tipos, dessa forma é bem simples
definir esses elementos. A sintaxe foi particularmente escolhida para esses
objetos.


*** Um exemplo usando Tipos

Embora não seja obrigatório, a informação sobre o tipo para as funções é
geralmente feita explicitamente. Não é obrigatório porque o compilador é esperto
o suficiente para descobrir esses tipos para você. Porém, é uma boa ideia
declarar os tipos explicitamente porque indica qual era a sua intenção quando
escreveu o programa e melhora o entendimento de quem for ler o código.

Vamos experimentar um pouco. A declaração de um tipo se faz usando =::=

#+begin_src haskell
f :: Int -> Int -> Int
f x y = x*x + y*y

main = print (f 2 3)
#+end_src

#+begin_src shell
~ runhaskell arquivo_com_codigo_acima_salvo.lhs
13
#+end_src


--------

Agora tente:

#+begin_src haskell
f :: Int -> Int -> Int
f x y = x*x + y*y

main = print (f 2.3 4.2)
#+end_src

Você deve receber esse erro:

#+begin_src shell
arquivo_com_codigo_acima_salvo.lhs:6:23:
    No instance for (Fractional Int)
      arising from the literal `4.2'
    Possible fix: add an instance declaration for (Fractional Int)
    In the second argument of `f', namely `4.2'
    In the first argument of `print', namely `(f 2.3 4.2)'
    In the expression: print (f 2.3 4.2)
#+end_src

O problema: =4.2= não é um =Int=.

--------

A solução: não declare o tipo para a função =f= por enquanto e deixe o Haskell
inferir o tipo mais genérico que ele conseguir para nós:

#+begin_src haskell
f x y = x*x + y*y

main = print (f 2.3 4.2)
#+end_src

Funcionou! Felizmente, não precisamos declarar uma nova função para cada tipo de
dado diferente que queremos suportar. Por exemplo, em =C= você teria que
declarar uma função que aceita =Int=, uma para =float=, uma para =long=, uma
para =double=, etc.

Mas quais tipos devemos declarar? Para descobrir o tipo que o Haskell encontrou
para nós, vamos utilizar o =ghci= (REPL):

#+begin_src shell
% ghci
GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude> let f x y = x*x + y*y
Prelude> :type f
f :: Num a => a -> a -> a
#+end_src

Uhm? Que tipo é esse?

#+begin_src haskell
Num a => a -> a -> a
#+end_src

Primeiro, vamos focar na parte da direita =a -> a -> a=. Para entender isso,
vamos analisar esses exemplos:

| Tipo           | Significado                                                            |
|----------------+------------------------------------------------------------------------|
| =Int=          | o tipo =Int=                                                           |
| =Int -> Int=   | uma função tipada que mapeia de =Int= para =Int=                       |
| =Float -> Int= | uma função tipada que mapeia de =Float= para =Int=                     |
| =a -> Int=     | uma função tipada que mapeia qualquer tipo para =Int=                  |
| =a -> a=       | uma função tipada que mapeia qualquer tipo =a= para o mesmo tipo =a=   |
| =a -> a -> a=  | uma função tipada de dois argumentos de tipo =a= para o mesmo tipo =a= |

No tipo =a -> a -> a=, a letra =a= é uma =variável de tipo=. Isso significa que
=f= é uma função com dois argumentos e ambos os argumentos e o resultado tem o
mesmo tipo. A variável de tipo =a= pode assumir vários valores de tipos
diferentes, por exemplo, =Int=, =Integer=, =Float=, etc.
